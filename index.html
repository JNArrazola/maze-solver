<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth Solver</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }

        .grid {
    display: grid;
    grid-template-columns: repeat(20, 30px); /* Cambiar el número 20 según el tamaño del laberinto */
    grid-auto-rows: 30px;
    gap: 1px;
    margin-bottom: 20px;
}

        .cell {
            width: 30px;
            height: 30px;
            background-color: white;
            border: 1px solid #ddd;
        }

        .wall {
            background-color: black;
        }

        .start {
            background-color: green;
        }

        .end {
            background-color: red;
        }

        .path {
            background-color: yellow;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

    <div class="grid"></div>
    <!-- <button id="bfsButton">Resolver con BFS</button>
    <button id="dfsButton">Resolver con DFS</button>
    <button id="aStarButton">Resolver con A*</button>
 -->
    <script>
        const maze = [
            [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            [0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0],
            [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0],
            [0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],
            [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0],
            [0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0],
            [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0],
            [0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],
            [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0],
            [0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1],
            [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0],
            [0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0],
            [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1]
        ];

        const rows = maze.length;
        const cols = maze[0].length;
        const start = [0, 0];
        const end = [rows - 1, cols -1];

        const gridElement = document.querySelector('.grid');
        const bfsButton = document.getElementById('bfsButton');
        const dfsButton = document.getElementById('dfsButton');
        const aStarButton = document.getElementById('aStarButton');

        function drawMaze() {
    gridElement.style.gridTemplateColumns = `repeat(${cols}, 30px)`; // Ajusta las columnas dinámicamente
    gridElement.innerHTML = ""; 
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            if (maze[row][col] === 1) {
                cell.classList.add('wall');
            }
            if (row === start[0] && col === start[1]) {
                cell.classList.add('start');
            }
            if (row === end[0] && col === end[1]) {
                cell.classList.add('end');
            }
            gridElement.appendChild(cell);
        }
    }
}


        function resetMaze() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('path');
            });
        }

        function bfsSolveMaze() {
    resetMaze(); 
    const queue = [[start]]; 
    const visited = new Set([posKey(start[0], start[1])]); 
    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; 

    while (queue.length > 0) {
        const path = queue.shift(); 
        const [row, col] = path[path.length - 1]; 

        if (row === end[0] && col === end[1]) {
            drawPath(path);
            return;
        }

        for (const [dx, dy] of directions) {
            const newRow = row + dx;
            const newCol = col + dy;

            if (
                newRow >= 0 && newRow < rows &&
                newCol >= 0 && newCol < cols &&
                maze[newRow][newCol] === 0 &&
                !visited.has(posKey(newRow, newCol))
            ) {
                visited.add(posKey(newRow, newCol));
                queue.push([...path, [newRow, newCol]]); 
            }
        }
    }
}


        function dfsSolveMaze() {
            resetMaze(); 
            const stack = [[start]]; 
            const visited = new Set([start.toString()]); 
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; 

            while (stack.length > 0) {
                const path = stack.pop(); 
                const [row, col] = path[path.length - 1]; 

                if (row === end[0] && col === end[1]) {
                    drawPath(path);
                    return;
                }

                for (const [dx, dy] of directions) {
                    const newRow = row + dx;
                    const newCol = col + dy;
                    const newPos = [newRow, newCol];

                    if (
                        newRow >= 0 && newRow < rows &&
                        newCol >= 0 && newCol < cols &&
                        maze[newRow][newCol] === 0 &&
                        !visited.has(newPos.toString())
                    ) {
                        visited.add(newPos.toString());
                        stack.push([...path, newPos]); 
                    }
                }
            }
        }

        function aStarSolveMaze() {
            resetMaze(); 
            const openSet = [[start]]; 
            const gScore = new Map();
            gScore.set(start.toString(), 0);

            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];

            while (openSet.length > 0) {
                const path = openSet.shift(); 
                const [row, col] = path[path.length - 1]; 

                if (row === end[0] && col === end[1]) {
                    drawPath(path);
                    return;
                }

                for (const [dx, dy] of directions) {
                    const newRow = row + dx;
                    const newCol = col + dy;
                    const newPos = [newRow, newCol];

                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && maze[newRow][newCol] === 0) {
                        const tentative_gScore = gScore.get(path.toString()) + 1;
                        if (!gScore.has(newPos.toString()) || tentative_gScore < gScore.get(newPos.toString())) {
                            gScore.set(newPos.toString(), tentative_gScore);
                            const estimated_fScore = tentative_gScore + heuristic(newPos, end);
                            openSet.push([...path, newPos]);
                            openSet.sort((a, b) => heuristic(a[a.length - 1], end) - heuristic(b[b.length - 1], end));
                        }
                    }
                }
            }
        }

        function heuristic(pos, end) {
            return Math.abs(pos[0] - end[0]) + Math.abs(pos[1] - end[1]);
        }

        function drawPath(path) {
            path.forEach(([row, col], index) => {
                setTimeout(() => {
                    const cellIndex = row * cols + col;
                    const cell = gridElement.children[cellIndex];
                    if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                        cell.classList.add('path');
                    }
                }, index * 200); 
            });
        }

        drawMaze();

        bfsButton.addEventListener('click', () => {
            bfsSolveMaze();
        });

        dfsButton.addEventListener('click', () => {
            dfsSolveMaze();
        });

        aStarButton.addEventListener('click', () => {
            aStarSolveMaze();
        });

    </script>

</body>
</html>
